package br.usp.poli.takiyama.acfove;

import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.Stack;

import br.usp.poli.takiyama.common.Constraint;
import br.usp.poli.takiyama.common.Marginal;
import br.usp.poli.takiyama.common.Parfactor;
import br.usp.poli.takiyama.common.SplitResult;
import br.usp.poli.takiyama.common.StdMarginal.StdMarginalBuilder;
import br.usp.poli.takiyama.prv.Binding;
import br.usp.poli.takiyama.prv.NameGenerator;
import br.usp.poli.takiyama.prv.Prv;
import br.usp.poli.takiyama.prv.Prvs;
import br.usp.poli.takiyama.prv.Substitution;
import br.usp.poli.takiyama.prv.Term;
import br.usp.poli.takiyama.utils.Sets;

public final class Shatter extends AbstractMacroOperation {
	
	public Shatter(Marginal<Prv> marginal) {
		super.marginal = new StdMarginalBuilder(marginal).build();
	}
	
	/**
	 * Makes all the necessary splits and expansions to 
	 * guarantee that the sets of random variables represented by parameterized
	 * random variables in each parfactor of the current distribution are equal 
	 * or disjoint.
	 * <p>
	 * In other words, for any parameterized random variables p and q from
	 * parfactors of the current distribution, p and q represent identical or
	 * disjoint sets of random variables.
	 * </p>
	 * <p>
	 * This operation is used before multiplication and elimination 
	 * on parfactors.
	 * </p>
	 * <p>
	 * If the current distribution is empty, nothing is done.
	 * </p>
	 */
	public void run() {
		if (marginal.distribution().isEmpty()) {
			return;
		}
		
		simplifyLogicalVariables();
		renameAllLogicalVariables();
				
		Stack<Parfactor> parfactorsToProcess = new Stack<Parfactor>();
		parfactorsToProcess.addAll(marginal.distribution().toSet());
		
		// in case we unify aggregation parfactors
		Set<Prv> eliminables = marginal.eliminables();
		
		// A set of shattered parfactors
		Set<Parfactor> shatteredSet = new HashSet<Parfactor>();
		// A temporary set of shattered parfactors
		Set<Parfactor> shatteredPool = new HashSet<Parfactor>();
		
		while (!parfactorsToProcess.isEmpty()) {
			Parfactor p1 = parfactorsToProcess.pop();
			while (!parfactorsToProcess.isEmpty()) {
				if (!parfactorsToProcess.isEmpty()) {
					Parfactor p2 = parfactorsToProcess.pop();
					Marginal<Prv> unifiedSet = unify(p1, p2);
					if (unifiedSet.isEmpty()) {
						shatteredPool.add(p2);
					} else {
						parfactorsToProcess.addAll(unifiedSet.distribution().toSet());
						eliminables.addAll(unifiedSet.eliminables());
						parfactorsToProcess.addAll(shatteredPool);
						parfactorsToProcess.addAll(shatteredSet);
						shatteredPool.clear();
						shatteredSet.clear();
						p1 = parfactorsToProcess.pop();
					}
				}
			}
			shatteredSet.add(p1);
			parfactorsToProcess.addAll(shatteredPool);
			shatteredPool.clear();
		}
		
		shatteredSet = Sets.apply(NameGenerator.getOldNames(), shatteredSet);
		eliminables = Sets.apply(NameGenerator.getOldNames(), eliminables);
		marginal = new StdMarginalBuilder().parfactors(shatteredSet)
				.eliminables(eliminables).build();
	}
	
	/**
	 * Replaces logical variables constrained to a single constant with this
	 * constant in all parfactors in the distribution.
	 */
	private void simplifyLogicalVariables() {
		StdMarginalBuilder m = new StdMarginalBuilder(this.marginal);
		for (Parfactor p : this.marginal) {
			m.set(p, p.simplifyLogicalVariables());
		}
		this.marginal = m.build();
	}
	
	
	/**
	 * Renames logical variables in parfactors. This is done to avoid repetition
	 * of logical variable names from different parfactors.
	 */
	private void renameAllLogicalVariables() {
		StdMarginalBuilder m = new StdMarginalBuilder(this.marginal);
		for (Parfactor p : this.marginal) {
			m.set(p, renameLogicalVariables(p));
		}
		this.marginal = m.build();
	}
	
	/**
	 * Renames logical variables from the specified parfactor. Names are 
	 * generated by a {@link NameGenerator}.
	 */
	private Parfactor renameLogicalVariables(Parfactor p) {
		return p.apply(NameGenerator.rename(p.logicalVariables()));
	}
	
	/*
	 * Tries to unify two parfactors. This function returns on the first 
	 * oportunity where a pair of PRVs unify.
	 * To unify two parfactors it may be necessary to call this function 
	 * several times.
	 * Returns an empty Marginal if p1 and p2 do not have unifiable PRVs.
	 */
	private Marginal<Prv> unify(Parfactor p1, Parfactor p2) {
		for (Prv prv1 : p1.prvs()) {
			for (Prv prv2 : p2.prvs()) {
				Marginal<Prv> result = unify(p1, prv1, p2, prv2);
				if (!result.isEmpty()) {
					return result;
				}
			}
		}
		return new StdMarginalBuilder().build();
	}
	
	/**
	 * Unifies p1 and p2 on variables prv1 and prv2.
	 * prv1 must belong to p1 and prv2 must belong to p2, although no check is
	 * made to assure that. You will get a warming IndexOutOfBoundsException if 
	 * you try to do that =) 
	 * Returns an empty Marginal if prv1 and prv2 do not unify.
	 */
	private Marginal<Prv> unify(Parfactor p1, Prv prv1, Parfactor p2, Prv prv2) {
		
		// Stores the reference for prv1 and prv2 (they change if they unify)
		int indexOfPrv1 = p1.prvs().indexOf(prv1);
		int indexOfPrv2 = p2.prvs().indexOf(prv2);
		
		StdMarginalBuilder result = new StdMarginalBuilder();
		
		try {
			Substitution mgu = Prvs.mgu(prv1, prv2);
			
			// Now must check whether MGU is consistent with all constraints,
			// including constraints from counting formulas
			Set<Constraint> allConstraints = Sets.union(p1.constraints(), 
					p2.constraints(), prv1.constraints(), prv2.constraints());
			if (!mgu.isEmpty() && mgu.isConsistentWith(allConstraints)) {
				
				// Splits p1 and p2 on MGU
				SplitResult firstSplit = split(p1, mgu);
				SplitResult secondSplit = split(p2, mgu);
				
				// Splits first result on second result constraints 
				prv2 = secondSplit.result().prvs().get(indexOfPrv2);
				allConstraints = Sets.union(secondSplit.result().constraints(), prv2.constraints());
				SplitResult firstSplitOnConstraints = split(firstSplit, allConstraints);
								
				// Splits second result on first result constraints >> keep symmetry
				prv1 = firstSplit.result().prvs().get(indexOfPrv1);
				allConstraints = Sets.union(firstSplit.result().constraints(), prv1.constraints());
				SplitResult secondSplitOnConstraints = split(secondSplit, allConstraints);
				
				// Put everything together
				result.union(firstSplitOnConstraints, secondSplitOnConstraints);
			} else {
				// PRVs are not unifiable
			}
		} catch (IllegalArgumentException e) {
			// PRVs are represent disjoint sets of random variables
		}
		
		return result.build();
	}
	
	/**
	 * Returns the result of splitting the specified parfactor on the 
	 * specified MGU
	 * <p>
	 * When the MGU is consistent with a set of inequality constraints,
	 * parameterized random variables represent non-disjoint and possibly
	 * non-identical sets of random variables. To make then identical, we 
	 * split the parfactor involved on the MGU.
	 * </p>
	 * <p>
	 * This method splits the specified parfactor in all substitutions present 
	 * in the MGU. The result depends on the order in which substitutions are
	 * made.
	 * </p>
	 * 
	 * @param parfactor The parfactor to split
	 * @param mgu The Most General Unifier to split this parfactor.
	 * @return The result of splitting the specified parfactor on the 
	 * specified MGU
	 */
	private SplitResult split(Parfactor parfactor, Substitution mgu) {
		Parfactor result = parfactor;
		StdMarginalBuilder residues = new StdMarginalBuilder();
		for (Binding bind : mgu.asList()) {
			if (result.logicalVariables().contains(bind.firstTerm())) {
				
				// expands all counting formulas - not sure if it is the right thing to do
				result = expand(result, bind.secondTerm());
				
				Substitution bindAsSub = Substitution.getInstance(bind);
				if (result.isSplittable(bindAsSub)) {
					SplitResult split = result.splitOn(bindAsSub);
					result = split.result();
					residues.parfactors(split.residue())
							.eliminables(split.eliminables());
				} else {
					result = result.apply(bindAsSub);
				}
			}
		}
		// works for std split result too
		return SplitResult.getInstance(result, residues.build()); 
	}
	
	/**
	 * Returns the result of splitting the specified parfactor on the 
	 * specified constraints.
	 * The only difference is that constraints are converted to substitutions 
	 * and splits are made on residues.
	 * 
	 * @see #split(Parfactor, Substitution)
	 */
	private SplitResult split(SplitResult splitResult, Set<Constraint> constraints) {
		Parfactor residue = splitResult.result();
		StdMarginalBuilder byProduct = new StdMarginalBuilder();
		byProduct.parfactors(splitResult.residue());
		byProduct.eliminables(splitResult.eliminables());
		for (Constraint constraint : constraints) {
			
			// Need to check both terms from constraint
			residue = expand(residue, constraint.firstTerm());
			residue = expand(residue, constraint.secondTerm());
			
			Substitution constraintAsSub;
			try {
				constraintAsSub = Substitution.getInstance(constraint.toBinding());
			} catch (IllegalStateException e) {
				constraintAsSub = Substitution.getInstance(constraint.toInverseBinding());
			}
			if (residue.isSplittable(constraintAsSub)) {
				SplitResult split = residue.splitOn(constraintAsSub);
				residue = split.residue().iterator().next();
				byProduct.parfactors(split.result())
				.eliminables(split.eliminables());
				
			} 
		}
		return SplitResult.getInstance(residue, byProduct.build());
	}
	
	/**
	 * Returns the result of expanding all counting formulas from the 
	 * specified parfactor on the specified term. Expansion is made only if
	 * conditions for expansion are met.
	 */
	private Parfactor expand(Parfactor parfactor, Term term) {
		List<Prv> variables = parfactor.prvs();
		for (Prv prv : variables) {
			if (parfactor.isExpandable(prv, term)) {
				parfactor = parfactor.expand(prv, term);
			}
		}
		return parfactor;
	}
}
