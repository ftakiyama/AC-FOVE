package br.usp.poli.takiyama.acfove;

import java.util.HashSet;
import java.util.Set;
import java.util.Stack;

import br.usp.poli.takiyama.common.Constraint;
import br.usp.poli.takiyama.common.Distribution;
import br.usp.poli.takiyama.common.Marginal;
import br.usp.poli.takiyama.common.Parfactor;
import br.usp.poli.takiyama.common.SplitResult;
import br.usp.poli.takiyama.common.StdDistribution;
import br.usp.poli.takiyama.common.UnconstrainedMarginal;
import br.usp.poli.takiyama.prv.Binding;
import br.usp.poli.takiyama.prv.LogicalVariable;
import br.usp.poli.takiyama.prv.NameGenerator;
import br.usp.poli.takiyama.prv.Prv;
import br.usp.poli.takiyama.prv.Prvs;
import br.usp.poli.takiyama.prv.Substitution;
import br.usp.poli.takiyama.utils.Sets;

public final class Shatter extends AbstractMacroOperation {
	
	public Shatter(Marginal<? extends Prv> marginal) {
		super.dist = marginal.distribution();
		super.varsToEliminate = marginal.eliminables();
	}
	
	/**
	 * Makes all the necessary splits and expansions to 
	 * guarantee that the sets of random variables represented by parameterized
	 * random variables in each parfactor of the current distribution are equal 
	 * or disjoint.
	 * <p>
	 * In other words, for any parameterized random variables p and q from
	 * parfactors of the current distribution, p and q represent identical or
	 * disjoint sets of random variables.
	 * </p>
	 * <p>
	 * This operation is used before multiplication and elimination 
	 * on parfactors.
	 * </p>
	 * <p>
	 * If the current distribution is empty, nothing is done.
	 * </p>
	 * 
	 * @param parfactors The set of parfactors to shatter.
	 * @return The specified set of parfactors shattered, or an empty set if
	 * the specified set is also empty.
	 */
	public void run() {
		if (distribution().isEmpty()) {
			return;
		}
		
		simplifyLogicalVariables();
		renameLogicalVariables();
		
		NameGenerator.getOldNames();
		
		Stack<Parfactor> parfactorsToProcess = new Stack<Parfactor>();
		parfactorsToProcess.addAll(distribution().toSet());
		
		// in case we unify aggregation parfactors
		Set<Prv> eliminables = new HashSet<Prv>();
		
		Set<Parfactor> shatteredSet = new HashSet<Parfactor>();
		Set<Parfactor> shatteredPool = new HashSet<Parfactor>();
		
		while (!parfactorsToProcess.isEmpty()) {
			Parfactor p1 = parfactorsToProcess.pop();
			while (!parfactorsToProcess.isEmpty()) {
				if (!parfactorsToProcess.isEmpty()) {
					Parfactor p2 = parfactorsToProcess.pop();
					Marginal<Prv> unifiedSet = unify(p1, p2);
					if (unifiedSet.isEmpty()) {
						shatteredPool.add(p2);
					} else {
						parfactorsToProcess.addAll(unifiedSet.distribution().toSet());
						// TODO need to add parfactors from the unifiedSet but also need to preserve the eliminables
						eliminables.addAll(unifiedSet.eliminables());
						parfactorsToProcess.addAll(shatteredPool);
						parfactorsToProcess.addAll(shatteredSet);
						shatteredPool.clear();
						shatteredSet.clear();
						p1 = parfactorsToProcess.pop();
					}
				}
			}
			shatteredSet.add(p1);
			parfactorsToProcess.addAll(shatteredPool);
			shatteredPool.clear();
		}
		
		dist = StdDistribution.of(Sets.apply(NameGenerator.getOldNames(), shatteredSet));
		varsToEliminate = Sets.apply(NameGenerator.getOldNames(), eliminables); 
	}
	
	private void simplifyLogicalVariables() {
		Distribution d = StdDistribution.of();
		for (Parfactor p : distribution().toSet()) {
			d = d.add(p.simplifyLogicalVariables());
		}
		this.dist = d;
		
		//TODO what about eliminables? Cannot apply same procedure, must keep
		// references because i dont know to which parfactor they belong
	}
	
	private void renameLogicalVariables() {
		Distribution d = StdDistribution.of();
		for (Parfactor p : distribution().toSet()) {
			d = d.add(renameLogicalVariables(p));
		}
		this.dist = d;
		
		//TODO what about eliminables?
	}
	
	/**
	 * Renames the logical variables of the specified parfactor. Names are 
	 * generated by a {@link NameGenerator}.
	 */
	private Parfactor renameLogicalVariables(Parfactor p) {
		Parfactor renamed = p;
		for (LogicalVariable v : p.logicalVariables()) {
			Binding bind = Binding.getInstance(v, NameGenerator.rename(v));
			Substitution s = Substitution.getInstance(bind);
			renamed = renamed.apply(s);
		}
		return renamed;
	}
	
	// return na primeira oportunidade em que f1 in p1 e f2 em p2 unificam
	private Marginal<Prv> unify(Parfactor p1, Parfactor p2) {
		
//		p1 = renameLogicalVariables(p1.simplifyLogicalVariables());
//		p2 = renameLogicalVariables(p2.simplifyLogicalVariables());
		
		for (Prv prv1 : p1.prvs()) {
			for (Prv prv2 : p2.prvs()) {
				Marginal<Prv> result = unify(p1, prv1, p2, prv2);
				if (!result.isEmpty()) {
//					result = restoreLogicalVariables(result);
					return result;
				}
			}
		}
		return UnconstrainedMarginal.getInstance();
	}
	
	// unifica os parfactors p1 e p2 nas vari‡veis prv1 e prv2
	private Marginal<Prv> unify(Parfactor p1, Prv prv1, Parfactor p2, Prv prv2) {
		
		int indexOfPrv1 = p1.prvs().indexOf(prv1);
		int indexOfPrv2 = p2.prvs().indexOf(prv2);
		
//		p1 = renameLogicalVariables(p1.simplifyLogicalVariables());
//		p2 = renameLogicalVariables(p2.simplifyLogicalVariables());
//		prv1 = p1.prvs().get(indexOfPrv1);
//		prv2 = p2.prvs().get(indexOfPrv2);

		Marginal<Prv> result = UnconstrainedMarginal.getInstance();
		
		try {
			Substitution mgu = Prvs.mgu(prv1, prv2);
			Set<Constraint> allConstraints = Sets.union(p1.constraints(), 
					p2.constraints(), prv1.constraints(), prv2.constraints());
			if (!mgu.isEmpty() && mgu.isConsistentWith(allConstraints)) {
				SplitResult firstSplit = split(p1, mgu);
				SplitResult secondSplit = split(p2, mgu);
				
				prv2 = secondSplit.result().prvs().get(indexOfPrv2);
				allConstraints = Sets.union(secondSplit.result().constraints(), prv2.constraints());
				firstSplit = split(firstSplit, allConstraints);
				
				prv1 = firstSplit.result().prvs().get(indexOfPrv1);
				allConstraints = Sets.union(firstSplit.result().constraints(), prv1.constraints());
				secondSplit = split(secondSplit, allConstraints);
				
				result = UnconstrainedMarginal.getInstance(firstSplit, secondSplit);
			}
		} catch (IllegalArgumentException e) {
			// prvs are disjoint
		}
		
		return result;
	}
	
	/**
	 * Returns the result of splitting the specified parfactor on the 
	 * specified MGU
	 * <p>
	 * When the MGU is consistent with a set of inequality constraints,
	 * parameterized random variables represent non-disjoint and possibly
	 * non-identical sets of random variables. To make then identical, we 
	 * split the parfactor involved on the MGU.
	 * </p>
	 * <p>
	 * This method splits the specified parfactor in all substitutions present 
	 * in the MGU. The result depends on the order in which substitutions are
	 * made.
	 * </p>
	 * 
	 * @param parfactor The parfactor to split
	 * @param mgu The Most General Unifier to split this parfactor.
	 * @return The result of splitting the specified parfactor on the 
	 * specified MGU
	 */
	private SplitResult split(Parfactor parfactor, Substitution mgu) {
		Parfactor result = parfactor;
		Marginal<Prv> residues = UnconstrainedMarginal.getInstance();
		for (Binding bind : mgu.asList()) {
			if (result.logicalVariables().contains(bind.firstTerm())) {
				
				// expands all counting formulas - not sure if it is the right thing to do
				for (Prv prv : parfactor.prvs()) {
					if (result.isExpandable(prv, bind.secondTerm())) {
						result = result.expand(prv, bind.secondTerm());
					}
				}
				
				Substitution bindAsSub = Substitution.getInstance(bind);
				if (result.isSplittable(bindAsSub)) {
					SplitResult split = result.splitOn(bindAsSub);
					result = split.result();
					residues = residues.addAll(split.residue());
				} else {
					result = result.apply(bindAsSub);
				}
			}
		}
		// works for std split result too
		return AggSplitResult.getInstance(result, residues); 
	}
	
	/**
	 * The only difference is that constraints are converted to substitutions 
	 * and splits are made on residues.
	 * 
	 * @see #split(Parfactor, Substitution)
	 */
	private SplitResult split(SplitResult splitResult, Set<Constraint> constraints) {
		Parfactor residue = splitResult.result();
		Marginal<Prv> byProduct = UnconstrainedMarginal.getInstance();
		byProduct = byProduct.addAll(splitResult.residue());
		for (Constraint constraint : constraints) {
			
			// expands all counting formulas - not sure if it is the right thing to do
			for (Prv prv : residue.prvs()) { // TODO it was argument here?
				if (residue.isExpandable(prv, constraint.secondTerm())) {
					residue = residue.expand(prv, constraint.secondTerm());
				}
			}
			
			Substitution constraintAsSub;
			try {
				constraintAsSub = Substitution.getInstance(constraint.toBinding());
			} catch (IllegalArgumentException e) {
				constraintAsSub = Substitution.getInstance(constraint.toInverseBinding());
			}
			if (residue.isSplittable(constraintAsSub)) {
				SplitResult split = residue.splitOn(constraintAsSub);
				residue = split.residue().iterator().next(); // unchecked
				byProduct = byProduct.add(split.result());
			} 
		}
		return AggSplitResult.getInstance(residue, byProduct);
	}
	
	private Marginal<Prv> restoreLogicalVariables(Marginal<Prv> marginal) {
		Marginal<Prv> renamed = marginal.apply(NameGenerator.getOldNames());
		return renamed;
	}
}
